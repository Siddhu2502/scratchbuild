<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/profile/logo.png" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/svg+xml" href="/profile/logo.png" media="(prefers-color-scheme: light)"><link rel="icon" type="image/x-icon" href="/profile/logo.png"><meta name="generator" content="Astro v4.16.18"><!-- Font preloads --><link rel="preload" href="/_astro/inter-latin-400-normal.BOOGhInR.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/inter-latin-600-normal.D273HNI0.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-400-normal.CvHVDnm4.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/lora-latin-600-normal.DUWh3m6k.woff2" as="font" type="font/woff2" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://siddhu.serveris.live/blog/dsa/lc-hashmap/"><!-- Primary Meta Tags --><title>Hashmap Patterns in LeetCode Problems (Medium) | Siddharth</title><meta name="title" content="Hashmap Patterns in LeetCode Problems (Medium) | Siddharth"><meta name="description" content="A comprehensive guide to mastering hash map patterns through LeetCode problems."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://siddhu.serveris.live/blog/dsa/lc-hashmap/"><meta property="og:title" content="Hashmap Patterns in LeetCode Problems (Medium) | Siddharth"><meta property="og:description" content="A comprehensive guide to mastering hash map patterns through LeetCode problems."><meta property="og:image" content="https://siddhu.serveris.live/blog/dsa/lc-hashmap/profile/logo.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://siddhu.serveris.live/blog/dsa/lc-hashmap/"><meta property="twitter:title" content="Hashmap Patterns in LeetCode Problems (Medium) | Siddharth"><meta property="twitter:description" content="A comprehensive guide to mastering hash map patterns through LeetCode problems."><meta property="twitter:image" content="https://siddhu.serveris.live/blog/dsa/lc-hashmap/profile/logo.png"><!-- 100% privacy-first analytics --><script data-collect-dnt="true" async src="https://scripts.simpleanalyticscdn.com/latest.js"></script><noscript><img src="https://queue.simpleanalyticscdn.com/noscript.gif?collect-dnt=true" alt="" referrerpolicy="no-referrer-when-downgrade"></noscript><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-37NQM5JQV0"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-37NQM5JQV0');
</script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script>
  function init() {
    preloadTheme();
    onScroll();
    animate();

    const backToTop = document.getElementById("back-to-top");
    backToTop?.addEventListener("click", (event) => scrollToTop(event));

    const backToPrev = document.getElementById("back-to-prev");
    backToPrev?.addEventListener("click", () => window.history.back());

    const lightThemeButton = document.getElementById("light-theme-button");
    lightThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "light");
      toggleTheme(false);
    });

    const darkThemeButton = document.getElementById("dark-theme-button");
    darkThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "dark");
      toggleTheme(true);
    });

    const systemThemeButton = document.getElementById("system-theme-button");
    systemThemeButton?.addEventListener("click", () => {
      localStorage.setItem("theme", "system");
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    });

    window.matchMedia("(prefers-color-scheme: dark)")
      .addEventListener("change", event => {
        if (localStorage.theme === "system") {
          toggleTheme(event.matches);
        }
      }
    );

    document.addEventListener("scroll", onScroll);
  }

  function animate() {
    const animateElements = document.querySelectorAll(".animate");

    animateElements.forEach((element, index) => {
      setTimeout(() => {
        element.classList.add("show");
      }, index * 150);
    });
  }

  function onScroll() {
    if (window.scrollY > 0) {
      document.documentElement.classList.add("scrolled");
    } else {
      document.documentElement.classList.remove("scrolled");
    }
  }

  function scrollToTop(event) {
    event.preventDefault();
    window.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  }

function toggleTheme(dark) {
    const css = document.createElement("style");

    css.appendChild(
      document.createTextNode(
        `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
      )
    );

    document.head.appendChild(css);

    if (dark) {
      document.documentElement.classList.add("dark");
    } else {
      document.documentElement.classList.remove("dark");
    }

  window.getComputedStyle(css).opacity;
    document.head.removeChild(css);
  }

  function preloadTheme() {
    const userTheme = localStorage.theme;

    if (userTheme === "light" || userTheme === "dark") {
      toggleTheme(userTheme === "dark");
    } else {
      toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }

  document.addEventListener("DOMContentLoaded", () => init());
  document.addEventListener("astro:after-swap", () => init());
  preloadTheme();
</script><link rel="stylesheet" href="/_astro/_slug_.D9OGefqq.css"><script type="module" src="/_astro/hoisted.RlhmG3H2.js"></script></head> <body> <header> <div class="mx-auto max-w-screen-sm px-5">  <div class="flex flex-wrap gap-y-2 justify-between"> <a href="/" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out">  <div class="font-semibold"> Siddharth </div>  </a> <nav class="flex gap-1"> <a href="/blog" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
blog
 </a> <span> / </span> <a href="/work" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
work
 </a> <span> / </span> <a href="/projects" target="_self" class="inline-block decoration-black/15 dark:decoration-white/30 hover:decoration-black/25 hover:dark:decoration-white/50 text-current hover:text-black hover:dark:text-white transition-colors duration-300 ease-in-out underline underline-offset-2"> 
projects
 </a> </nav> </div>  </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-5">  <div class="animate"> <a href="/blog" class="relative group w-fit flex pl-7 pr-3 py-1.5 flex-nowrap rounded border border-black/15 dark:border-white/20 hover:bg-black/5 dark:hover:bg-white/5 hover:text-black dark:hover:text-white transition-colors duration-300 ease-in-out"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute top-1/2 left-2 -translate-y-1/2 size-4 stroke-2 fill-none stroke-current"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 group-hover:translate-x-0 scale-x-0 group-hover:scale-x-100 transition-transform duration-300 ease-in-out"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 group-hover:translate-x-0 transition-transform duration-300 ease-in-out"></polyline> </svg> <div class="text-sm"> 
Back to blog
 </div> </a> </div> <div class="space-y-1 my-10"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> <time datetime="2025-06-02T00:00:00.000Z"> Jun 2, 2025 </time> </div>
&bull;
<div class="font-base text-sm"> 18 min read </div> </div> <div class="animate text-2xl font-semibold text-black dark:text-white"> Hashmap Patterns in LeetCode Problems (Medium) </div> </div> <article class="animate"> <h3 id="group-1-basic-frequency-counting--existence-checks">Group 1: Basic Frequency Counting &#x26; Existence Checks</h3>
<p>This group introduces the most fundamental use of hash maps: counting element occurrences or checking for their existence. Problems start with simple counting and progress to using maps to track state across more complex data structures like a 2D grid.</p>











































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>1</td><td>Find All Duplicates in an Array</td><td><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">Link</a></td><td>Frequency Counting</td><td>Base case: Use a hash map to count integer occurrences and identify those that appear twice.</td></tr><tr><td>2</td><td>Rabbits in Forest</td><td><a href="https://leetcode.com/problems/rabbits-in-forest/">Link</a></td><td>Frequency Counting</td><td>Adds a layer of logic on top of frequency counts. You must interpret the counts according to the problem’s grouping rules.</td></tr><tr><td>3</td><td>Bulls and Cows</td><td><a href="https://leetcode.com/problems/bulls-and-cows/">Link</a></td><td>Frequency Counting</td><td>Requires two passes or a single clever pass. Introduces managing two types of counts (bulls vs. cows) based on character and position.</td></tr><tr><td>4</td><td>K-diff Pairs in an Array</td><td><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/">Link</a></td><td>Frequency Counting</td><td>Builds on counting by requiring a second pass over the map’s keys to find pairs that satisfy a specific condition (difference of k).</td></tr><tr><td>5</td><td>Valid Sudoku</td><td><a href="https://leetcode.com/problems/valid-sudoku/">Link</a></td><td>Existence Check (Hash Set)</td><td>Applies the existence check pattern to a 2D grid. Requires managing 27 different sets (9 rows, 9 columns, 9 boxes) simultaneously.</td></tr><tr><td>6</td><td>Set Matrix Zeroes</td><td><a href="https://leetcode.com/problems/set-matrix-zeroes/">Link</a></td><td>State Tracking (Hash Set)</td><td>Uses hash sets not for counting, but to store the rows and columns that need to be modified, separating the “finding” and “setting” phases.</td></tr><tr><td>7</td><td>Subdomain Visit Count</td><td><a href="https://leetcode.com/problems/subdomain-visit-count/">Link</a></td><td>Frequency Counting</td><td>Adds significant string parsing logic. You must first process the input strings into subdomains before applying the counting pattern.</td></tr><tr><td>8</td><td>Finding the Users Active Minutes</td><td><a href="https://leetcode.com/problems/finding-the-users-active-minutes/">Link</a></td><td>Frequency Counting</td><td>Involves a nested data structure: a hash map where each value is a hash set, to count unique minutes per user.</td></tr><tr><td>9</td><td>Display Table of Food Orders in a Restaurant</td><td><a href="https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/">Link</a></td><td>Frequency Counting</td><td>Requires managing nested counts (table -> food item -> count). Adds complexity of collecting all keys for table headers and sorting.</td></tr></tbody></table>
<h3 id="group-2-grouping-by-canonical-representation">Group 2: Grouping by Canonical Representation</h3>
<p>These problems use a hash map to group items. The key to the map is a “canonical” (standard) representation of an item, and the value is a list of all items that map to that key.</p>






















































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>10</td><td>Group Anagrams</td><td><a href="https://leetcode.com/problems/group-anagrams/">Link</a></td><td>Grouping</td><td>Foundational grouping problem. The canonical key is the sorted version of a string.</td></tr><tr><td>11</td><td>Find and Replace Pattern</td><td><a href="https://leetcode.com/problems/find-and-replace-pattern/">Link</a></td><td>Grouping / Pattern Matching</td><td>Introduces a more complex canonical key. You need to normalize each word into a numeric pattern (e.g., ‘abb’ -> ‘122’) to group them.</td></tr><tr><td>12</td><td>Groups of Special-Equivalent Strings</td><td><a href="https://leetcode.com/problems/groups-of-special-equivalent-strings/">Link</a></td><td>Grouping</td><td>A variation on the canonical key concept. The key must represent the counts of characters at both even and odd indices separately.</td></tr><tr><td>13</td><td>Determine if Two Strings Are Close</td><td><a href="https://leetcode.com/problems/determine-if-two-strings-are-close/">Link</a></td><td>Frequency Map Comparison</td><td>Instead of grouping, you create two frequency maps and compare them based on two conditions: same keys and same frequency values.</td></tr><tr><td>14</td><td>Word Subsets</td><td><a href="https://leetcode.com/problems/word-subsets/">Link</a></td><td>Frequency Map Comparison</td><td>Requires creating a single “max frequency” map from one list of words and then comparing each word from another list against it.</td></tr><tr><td>15</td><td>Find Duplicate File in System</td><td><a href="https://leetcode.com/problems/find-duplicate-file-in-system/">Link</a></td><td>Grouping</td><td>Adds string parsing to extract file content, which serves as the canonical key for grouping file paths.</td></tr></tbody></table>
<h3 id="group-3-frequency-counting-with-sorting-or-greedy-logic">Group 3: Frequency Counting with Sorting or Greedy Logic</h3>
<p>Here, the hash map is the first step in a two-step process. After counting frequencies, you must apply a sorting or greedy algorithm to the counts to find the answer.</p>











































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>16</td><td>Sort Characters by Frequency</td><td><a href="https://leetcode.com/problems/sort-characters-by-frequency/">Link</a></td><td>Frequency Count &#x26; Sort</td><td>Base case: Count character frequencies, then sort the characters based on those counts to build the result string.</td></tr><tr><td>17</td><td>Top K Frequent Elements</td><td><a href="https://leetcode.com/problems/top-k-frequent-elements/">Link</a></td><td>Frequency Count &#x26; Heap/Sort</td><td>Similar to the previous, but introduces finding the “top K” elements, making a Min-Heap or Quickselect an efficient follow-up step.</td></tr><tr><td>18</td><td>Top K Frequent Words</td><td><a href="https://leetcode.com/problems/top-k-frequent-words/">Link</a></td><td>Frequency Count &#x26; Heap/Sort</td><td>A “boring variation” that adds complexity to the sorting logic: you must handle ties using lexicographical order.</td></tr><tr><td>19</td><td>Reduce Array Size to the Half</td><td><a href="https://leetcode.com/problems/reduce-array-size-to-the-half/">Link</a></td><td>Frequency Count &#x26; Greedy</td><td>Introduces a greedy approach. After counting, you sort the frequencies and greedily remove the largest counts to solve the problem.</td></tr><tr><td>20</td><td>Least Number of Unique Integers after K Removals</td><td><a href="https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/">Link</a></td><td>Frequency Count &#x26; Greedy</td><td>Similar greedy logic, but now you remove the<em>smallest</em> counts first. Reinforces the pattern of operating on sorted frequencies.</td></tr><tr><td>21</td><td>Hand of Straights</td><td><a href="https://leetcode.com/problems/hand-of-straights/">Link</a></td><td>Frequency Count &#x26; Greedy</td><td>Requires more complex greedy logic. After counting, you must check for<em>consecutive</em> sequences, often by iterating through sorted keys.</td></tr><tr><td>22</td><td>Divide Array in Sets of K Consecutive Numbers</td><td><a href="https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/">Link</a></td><td>Frequency Count &#x26; Greedy</td><td>A “boring variation” of Hand of Straights. The underlying logic is identical.</td></tr><tr><td>23</td><td>Reorganize String</td><td><a href="https://leetcode.com/problems/reorganize-string/">Link</a></td><td>Frequency Count &#x26; Greedy Heap</td><td>The greedy logic becomes more complex, requiring a Max-Heap to always pick the most frequent character that is not adjacent to the last.</td></tr><tr><td>24</td><td>Distant Barcodes</td><td><a href="https://leetcode.com/problems/distant-barcodes/">Link</a></td><td>Frequency Count &#x26; Greedy Heap</td><td>A “boring variation” of Reorganize String with the same underlying greedy heap-based algorithm.</td></tr></tbody></table>
<h3 id="group-4-modulo-arithmetic--pairtuple-counting">Group 4: Modulo Arithmetic &#x26; Pair/Tuple Counting</h3>
<p>This set of problems combines frequency maps with modulo arithmetic or number theory to find pairs or combinations that satisfy a specific sum or divisibility property.</p>






















































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>25</td><td>Pairs of Songs with Total Durations Divisible by 60</td><td><a href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/">Link</a></td><td>Hashing with Modulo</td><td>Foundational problem for this pattern. Use a map to store counts of <code>time % 60</code> to find complementary pairs.</td></tr><tr><td>26</td><td>Check if Array Pairs Are Divisible by k</td><td><a href="https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/">Link</a></td><td>Hashing with Modulo</td><td>A “boring variation” of the previous problem, generalizing the logic from a fixed <code>60</code> to a variable <code>k</code>.</td></tr><tr><td>27</td><td>4Sum II</td><td><a href="https://leetcode.com/problems/4sum-ii/">Link</a></td><td>Hashing Pairs (Two-Sum)</td><td>Applies the two-sum pattern on a larger scale. You pre-compute and store sums of pairs from two arrays in a map to find <code>-(c+d)</code>.</td></tr><tr><td>28</td><td>Number of Pairs of Interchangeable Rectangles</td><td><a href="https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/">Link</a></td><td>Hashing with Ratios</td><td>Uses a map to count occurrences of a canonical key, which is the reduced fraction (ratio) of width to height.</td></tr><tr><td>29</td><td>Count Good Meals</td><td><a href="https://leetcode.com/problems/count-good-meals/">Link</a></td><td>Hashing Pairs (Two-Sum)</td><td>A variation of Two-Sum where the target isn’t fixed. For each number, you must check for complements for all possible powers of two.</td></tr><tr><td>30</td><td>Tuple with Same Product</td><td><a href="https://leetcode.com/problems/tuple-with-same-product/">Link</a></td><td>Hashing Pairs</td><td>Uses a hash map to count the frequency of products of pairs. The final calculation requires combinatorial logic (nC2).</td></tr></tbody></table>
<h3 id="group-5-sliding-window-with-hash-maps">Group 5: Sliding Window with Hash Maps</h3>
<p>In these problems, a hash map is used to maintain the state of a “sliding window” as it moves across an array or string. This is a powerful and common pattern.</p>





























































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>31</td><td>Longest Substring Without Repeating Characters</td><td><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Link</a></td><td>Sliding Window</td><td>The classic introduction to using a map in a sliding window to track characters and their last seen positions.</td></tr><tr><td>32</td><td>Fruit Into Baskets</td><td><a href="https://leetcode.com/problems/fruit-into-baskets/">Link</a></td><td>Sliding Window</td><td>A slight variation where the window’s constraint is having at most 2 distinct character types (fruits).</td></tr><tr><td>33</td><td>Permutation in String</td><td><a href="https://leetcode.com/problems/permutation-in-string/">Link</a></td><td>Sliding Window (Fixed)</td><td>Introduces a fixed-size window. Requires two maps: one for the target string and one for the current window, which you compare.</td></tr><tr><td>34</td><td>Find All Anagrams in a String</td><td><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Link</a></td><td>Sliding Window (Fixed)</td><td>A “boring variation” of the previous problem. Instead of returning true/false, you collect all starting indices of valid anagrams.</td></tr><tr><td>35</td><td>Maximum Erasure Value</td><td><a href="https://leetcode.com/problems/maximum-erasure-value/">Link</a></td><td>Sliding Window</td><td>Combines the unique-element window from “Longest Substring” with calculating a sum, rather than just the length of the window.</td></tr><tr><td>36</td><td>Longest Repeating Character Replacement</td><td><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">Link</a></td><td>Sliding Window</td><td>Introduces a more complex window condition:<code>window_length - max_frequency &#x3C;= k</code>. Requires efficiently tracking the max frequency.</td></tr><tr><td>37</td><td>Find the Longest Substring Containing Vowels in Even Counts</td><td><a href="https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/">Link</a></td><td>Sliding Window &#x26; Bitmask</td><td>Advanced pattern combining a hash map with bitmasking. The map stores <code>mask -> first_index</code> to find subarrays with a target parity state.</td></tr></tbody></table>
<h3 id="group-6-prefix-sum-with-hash-maps">Group 6: Prefix Sum with Hash Maps</h3>
<p>This pattern is used to efficiently find subarrays or subsequences that sum to a specific target. A hash map stores prefix sums and their indices, allowing for O(1) lookups.</p>




































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>38</td><td>Subarray Sum Equals K</td><td><a href="https://leetcode.com/problems/subarray-sum-equals-k/">Link</a></td><td>Prefix Sum</td><td>The canonical problem for this pattern. You store counts of prefix sums in a map to find <code>current_sum - k</code>.</td></tr><tr><td>39</td><td>Binary Subarrays with Sum</td><td><a href="https://leetcode.com/problems/binary-subarrays-with-sum/">Link</a></td><td>Prefix Sum</td><td>A “boring variation” of Subarray Sum Equals K, cementing the core concept.</td></tr><tr><td>40</td><td>Count Number of Nice Subarrays</td><td><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/">Link</a></td><td>Prefix Sum</td><td>A re-framing of the same problem. You must first transform the input (odd=1, even=0) to see it as a standard subarray sum problem.</td></tr><tr><td>41</td><td>Contiguous Array</td><td><a href="https://leetcode.com/problems/contiguous-array/">Link</a></td><td>Prefix Sum</td><td>Another re-framing. By converting 0s to -1s, the problem becomes finding the longest subarray with a sum of 0.</td></tr><tr><td>42</td><td>Subarray Sums Divisible by K</td><td><a href="https://leetcode.com/problems/subarray-sums-divisible-by-k/">Link</a></td><td>Prefix Sum with Modulo</td><td>Combines the prefix sum pattern with modulo arithmetic. The map stores counts of <code>prefix_sum % k</code>.</td></tr><tr><td>43</td><td>Continuous Subarray Sum</td><td><a href="https://leetcode.com/problems/continuous-subarray-sum/">Link</a></td><td>Prefix Sum with Modulo</td><td>A variation of the previous problem that requires checking for a subarray length of at least 2.</td></tr><tr><td>44</td><td>Minimum Operations to Reduce X to Zero</td><td><a href="https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/">Link</a></td><td>Prefix Sum</td><td>Requires an insightful re-framing: the problem is equivalent to finding the<em>longest</em> middle subarray that sums to <code>total_sum - x</code>.</td></tr><tr><td>45</td><td>Remove Zero Sum Consecutive Nodes from Linked List</td><td><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">Link</a></td><td>Prefix Sum on Linked List</td><td>Applies the prefix sum pattern to a linked list. The map stores <code>prefix_sum -> node</code>, requiring pointer manipulation to remove sublists.</td></tr></tbody></table>
<h3 id="group-7-graphtree-traversal-with-hashing">Group 7: Graph/Tree Traversal with Hashing</h3>
<p>In graph and tree problems, hash maps are essential for tracking visited nodes (to avoid cycles) or for mapping old nodes to new nodes when creating a deep copy.</p>











































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>46</td><td>Employee Importance</td><td><a href="https://leetcode.com/problems/employee-importance/">Link</a></td><td>Graph Traversal (DFS/BFS)</td><td>Base case: Use a hash map to build an adjacency list (<code>id -> Employee</code>) for easy lookups, then perform a simple traversal (DFS or BFS) to sum values.</td></tr><tr><td>47</td><td>Linked List Cycle II</td><td><a href="https://leetcode.com/problems/linked-list-cycle-ii/">Link</a></td><td>Traversal &#x26; Visited Set</td><td>Uses a hash set to keep track of visited nodes in a linked list. The first repeated node found is the start of the cycle.</td></tr><tr><td>48</td><td>Clone Graph</td><td><a href="https://leetcode.com/problems/clone-graph/">Link</a></td><td>Graph Traversal &#x26; Cloning</td><td>The canonical graph cloning problem. A hash map (<code>old_node -> new_node</code>) is crucial for tracking visited/cloned nodes to avoid infinite loops and re-creations.</td></tr><tr><td>49</td><td>Copy List with Random Pointer</td><td><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">Link</a></td><td>Graph Traversal &#x26; Cloning</td><td>A “boring variation” of Clone Graph applied to a linked list with an extra <code>random</code> pointer, reinforcing the <code>old_node -> new_node</code> map pattern.</td></tr><tr><td>50</td><td>Open the Lock</td><td><a href="https://leetcode.com/problems/open-the-lock/">Link</a></td><td>BFS &#x26; Visited Set</td><td>A classic state-space search using BFS. A hash set is essential to store <code>visited</code> states (lock combinations) to prevent redundant exploration.</td></tr><tr><td>51</td><td>Minimum Genetic Mutation</td><td><a href="https://leetcode.com/problems/minimum-genetic-mutation/">Link</a></td><td>BFS &#x26; Visited Set</td><td>A “boring variation” of Open the Lock. The states are gene strings instead of numbers, but the BFS with a visited set pattern is identical.</td></tr><tr><td>52</td><td>Construct Binary Tree from Preorder and Inorder Traversal</td><td><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Link</a></td><td>Recursion &#x26; Index Lookup</td><td>A hash map is used as a critical optimization to store <code>value -> index</code> for the inorder traversal, allowing O(1) lookup of the root’s position.</td></tr><tr><td>53</td><td>Construct Binary Tree from Inorder and Postorder Traversal</td><td><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">Link</a></td><td>Recursion &#x26; Index Lookup</td><td>A “boring variation” of the previous problem, using the same inorder map but with postorder traversal logic.</td></tr><tr><td>54</td><td>Restore the Array from Adjacent Pairs</td><td><a href="https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/">Link</a></td><td>Graph Traversal</td><td>Requires building a graph (adjacency list via hash map) from pairs, finding an endpoint (a node with one neighbor), and then traversing to reconstruct.</td></tr></tbody></table>
<h3 id="group-8-dynamic-programming-with-hash-map-memoization">Group 8: Dynamic Programming with Hash Map Memoization</h3>
<p>In these problems, a hash map is used as a “memo” to store the results of previously computed subproblems, which is the core of top-down dynamic programming.</p>






















































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>55</td><td>Word Break</td><td><a href="https://leetcode.com/problems/word-break/">Link</a></td><td>DP with Memo</td><td>Classic DP problem. A hash set provides O(1) dictionary lookups, and a hash map can be used for memoization (<code>index -> boolean</code>) to store subproblem results.</td></tr><tr><td>56</td><td>Delete and Earn</td><td><a href="https://leetcode.com/problems/delete-and-earn/">Link</a></td><td>DP with Memo</td><td>The first step is using a hash map to aggregate points for each number. The problem then becomes a “House Robber” variation on the sorted keys of the map.</td></tr><tr><td>57</td><td>Longest Arithmetic Subsequence of Given Difference</td><td><a href="https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/">Link</a></td><td>DP with Memo</td><td>Introduces DP where the map state is <code>value -> length</code>. For each <code>num</code>, the length of the sequence is <code>1 + map[num - difference]</code>.</td></tr><tr><td>58</td><td>Longest String Chain</td><td><a href="https://leetcode.com/problems/longest-string-chain/">Link</a></td><td>DP with Memo</td><td>The DP state is <code>word -> longest_chain_length</code>. Requires sorting the words by length and building the solution by checking predecessors of each word.</td></tr><tr><td>59</td><td>Binary Trees with Factors</td><td><a href="https://leetcode.com/problems/binary-trees-with-factors/">Link</a></td><td>DP with Memo</td><td>The DP state is <code>number -> count_of_trees</code>. For each number, you iterate through its factors to calculate the total combinations.</td></tr><tr><td>60</td><td>Longest Arithmetic Subsequence</td><td><a href="https://leetcode.com/problems/longest-arithmetic-subsequence/">Link</a></td><td>DP with Memo</td><td>The DP state is more complex, requiring a nested map:<code>dp[index][difference]</code>. A map of maps (<code>map&#x3C;int, map&#x3C;int, int>></code>) is a natural fit for this.</td></tr></tbody></table>
<h3 id="group-9-custom-data-structure-design">Group 9: Custom Data Structure Design</h3>
<p>This group contains problems that require you to design and implement a class with specific methods and time complexities. A hash map is almost always the core component.</p>











































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>61</td><td>Encode and Decode TinyURL</td><td><a href="https://leetcode.com/problems/encode-and-decode-tinyurl/">Link</a></td><td>Design</td><td>The simplest design problem. Requires two hash maps for forward and reverse lookups (<code>long->short</code> and <code>short->long</code>).</td></tr><tr><td>62</td><td>Insert Delete GetRandom O(1)</td><td><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Link</a></td><td>Design</td><td>A classic design problem combining a hash map (<code>value -> index</code>) with an array for O(1) average time complexity on all operations.</td></tr><tr><td>63</td><td>Time-Based Key-Value Store</td><td><a href="https://leetcode.com/problems/time-based-key-value-store/">Link</a></td><td>Design</td><td>Introduces combining a hash map with another structure. The map’s value is a sorted list of <code>(timestamp, value)</code> pairs, requiring binary search for <code>get</code>.</td></tr><tr><td>64</td><td>Design Underground System</td><td><a href="https://leetcode.com/problems/design-underground-system/">Link</a></td><td>Design</td><td>Requires multiple hash maps to track different states: one for active check-ins and another to aggregate travel times between stations.</td></tr><tr><td>65</td><td>Snapshot Array</td><td><a href="https://leetcode.com/problems/snapshot-array/">Link</a></td><td>Design</td><td>A clever design for versioning. Each array index contains a map (<code>snap_id -> value</code>) or a sorted list to allow efficient historical lookups.</td></tr><tr><td>66</td><td>LRU Cache</td><td><a href="https://leetcode.com/problems/lru-cache/">Link</a></td><td>Design</td><td>A canonical design problem requiring a combination of a hash map (for O(1) lookups) and a doubly linked list (to manage recency).</td></tr><tr><td>67</td><td>Design Twitter</td><td><a href="https://leetcode.com/problems/design-twitter/">Link</a></td><td>Design</td><td>A more complex design involving multiple hash maps (<code>userId -> follows</code>, <code>userId -> tweets</code>) and merging sorted lists or using a heap to generate the feed.</td></tr><tr><td>68</td><td>Stock Price Fluctuation</td><td><a href="https://leetcode.com/problems/stock-price-fluctuation/">Link</a></td><td>Design</td><td>Combines a hash map for current prices with a sorted data structure (like a sorted map or two heaps) to efficiently track min and max prices.</td></tr><tr><td>69</td><td>Detect Squares</td><td><a href="https://leetcode.com/problems/detect-squares/">Link</a></td><td>Design</td><td>Requires storing point frequencies in a map. The <code>count</code> method involves iterating through existing points to find valid squares.</td></tr></tbody></table>
<h3 id="group-10-clever-hashing--miscellaneous-problems">Group 10: Clever Hashing &#x26; Miscellaneous Problems</h3>
<p>This final group includes problems where the hash map is used in a particularly clever way, as a minor utility in a larger algorithm, or for complex state tracking.</p>




































































<table><thead><tr><th>#</th><th>Problem</th><th>Link</th><th>Concept</th><th>Description of Difficulty Increase</th></tr></thead><tbody><tr><td>70</td><td>Longest Consecutive Sequence</td><td><a href="https://leetcode.com/problems/longest-consecutive-sequence/">Link</a></td><td>Clever Hashing (Set)</td><td>A classic problem solved with a clever trick: use a hash set for O(1) lookups and only start counting a sequence from its true starting number.</td></tr><tr><td>71</td><td>Letter Combinations of a Phone Number</td><td><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">Link</a></td><td>Backtracking &#x26; Lookup</td><td>The hash map is used as a simple utility (a lookup table for <code>digit -> letters</code>). The core logic is backtracking, not hashing.</td></tr><tr><td>72</td><td>Brick Wall</td><td><a href="https://leetcode.com/problems/brick-wall/">Link</a></td><td>Clever Hashing</td><td>The key insight is to use a hash map to count the frequency of “gaps” between bricks. The answer is <code>total_rows - max_gap_frequency</code>.</td></tr><tr><td>73</td><td>Fraction to Recurring Decimal</td><td><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/">Link</a></td><td>Simulation &#x26; State</td><td>A complex simulation of long division. The hash map is critical for detecting a cycle by storing <code>remainder -> position</code>.</td></tr><tr><td>74</td><td>Prison Cells After N Days</td><td><a href="https://leetcode.com/problems/prison-cells-after-n-days/">Link</a></td><td>Simulation &#x26; Cycle Detection</td><td>Since the state space is small, cycles must occur. A hash map (<code>state -> day</code>) is used to detect the cycle and calculate the final state.</td></tr><tr><td>75</td><td>Smallest Integer Divisible by K</td><td><a href="https://leetcode.com/problems/smallest-integer-divisible-by-k/">Link</a></td><td>Math &#x26; Cycle Detection</td><td>Similar to the above, this problem uses a hash set to detect when a <code>remainder % k</code> repeats, which indicates a non-terminating sequence.</td></tr><tr><td>76</td><td>Partition Labels</td><td><a href="https://leetcode.com/problems/partition-labels/">Link</a></td><td>Greedy &#x26; Pre-computation</td><td>A two-pass greedy solution. The first pass uses a hash map to pre-compute the last occurrence index of every character.</td></tr><tr><td>77</td><td>Task Scheduler</td><td><a href="https://leetcode.com/problems/task-scheduler/">Link</a></td><td>Greedy &#x26; Math</td><td>The hash map is used for initial frequency counting. The core logic is a mathematical or greedy approach to calculate idle time.</td></tr></tbody></table> </article>  </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-5">  <div class="relative"> <div class="absolute right-0 -top-20"> <button id="back-to-top" class="relative group w-fit flex pl-8 pr-3 py-1.5 flex-nowrap rounded border border-black/15 dark:border-white/20 hover:bg-black/5 dark:hover:bg-white/5 hover:text-black dark:hover:text-white transition-colors duration-300 ease-in-out"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute top-1/2 left-2 -translate-y-1/2 size-4 stroke-2 fill-none stroke-current rotate-90"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 group-hover:translate-x-0 scale-x-0 group-hover:scale-x-100 transition-transform duration-300 ease-in-out"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 group-hover:translate-x-0 transition-transform duration-300 ease-in-out"></polyline> </svg> <div class="text-sm">
Back to top
</div> </button> </div> </div> <div class="flex justify-between items-center"> <div>
&copy; 2025 | Siddharth </div> <div class="flex flex-wrap gap-1 items-center"> <button id="light-theme-button" aria-label="Light theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group size-8 flex items-center justify-center rounded-full"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out"> <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect> <line x1="8" y1="21" x2="16" y2="21"></line> <line x1="12" y1="17" x2="12" y2="21"></line> </svg> </button> </div> </div>  </div> </footer> </body></html>